{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Wholesale Lens — Stabilize startup, profile bootstrap, and hash-based payment routing",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Make startup state machine resilient so the app always renders a usable screen (sign-in, profile setup, dashboard, or stable error) without blank/infinite loading.",
      "acceptanceCriteria": [
        "Launching the app shows a visible UI within 30 seconds (loading, sign-in, or an actionable error screen).",
        "No uncaught exceptions occur during initial render (verify via browser console).",
        "If the backend/identity is unavailable, the user sees StartupErrorScreen with a working Retry button."
      ],
      "file_operations": [
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Refactor startup flow into an explicit, non-blocking state machine that cannot dead-end: (1) identity init -> (2) actor init -> (3) route gate (payment vs app) -> (4) profile bootstrap -> (5) AppShell/ProfileSetupDialog. Ensure the 30s watchdog always transitions to a stable StartupErrorScreen (never blank), and that retries reset the watchdog and only re-run the failed stage."
        },
        {
          "path": "frontend/src/hooks/useBackendActor.ts",
          "operation": "modify",
          "description": "Expose clearer readiness and failure signals for startup (e.g., distinguish identity still initializing vs actor creation failure) and ensure refetch provides a reliable manual recovery path when startup retry is pressed."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Unblock first-time authenticated users by gracefully bootstrapping profile access without requiring an admin token, and transition into the normal AppShell without refresh after saving profile.",
      "acceptanceCriteria": [
        "A newly authenticated principal can call `getCallerUserProfile` without receiving an unauthorized error.",
        "If the user has no completed profile (e.g., name is empty), the app shows ProfileSetupDialog and can save successfully.",
        "After saving a profile, the app transitions into the normal AppShell experience without requiring a page refresh."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Update the profile startup query logic to support first-time users: use the authorization component’s expected flow (getCallerUserProfile + saveCallerUserProfile) and add a one-time bootstrap fallback using the existing backend capability initializeProfile() when profile fetch fails in a way consistent with first-time setup. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/ProfileSetupDialog.tsx",
          "operation": "modify",
          "description": "Harden first-time profile setup UX: ensure save errors are clearly surfaced, and ensure successful save reliably unblocks the app by relying on the currentUserProfile query invalidation/refetch (no refresh). Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/AppShell.tsx",
          "operation": "modify",
          "description": "Ensure logout continues to clear cached app/profile data (react-query cache) so subsequent logins re-run the first-time profile flow correctly, aligning with the authorization component guidance. Verify the component's usage instructions before implementing."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Improve startup error reporting with user-readable root causes and correct retry actions for actor creation vs profile fetch vs routing issues, without retry loops.",
      "acceptanceCriteria": [
        "StartupErrorScreen displays an actionable, user-readable message derived from the underlying error (not just a generic fallback), while remaining safe (no secrets).",
        "The Retry button triggers the correct retry action (backend connection vs. profile fetch) and can recover without a full reload when the transient issue is resolved.",
        "The app does not get stuck in a retry loop; repeated failures keep the user on a stable error screen."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/StartupErrorScreen.tsx",
          "operation": "modify",
          "description": "Extend StartupErrorScreen to accept structured startup failure context (e.g., failure stage, safe technical detail string) and render an English, actionable message derived from the underlying error while omitting sensitive values. Ensure the Retry button label and behavior can be stage-specific. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Adjust error normalization for startup-critical queries so StartupErrorScreen can display a more specific, safe message (e.g., differentiate network/backend unavailable vs authorization/profile setup required), without leaking secrets."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Wire startup failures into StartupErrorScreen with correct retry actions per failure stage (actor refetch vs profile refetch vs route recomputation), and ensure retries are user-initiated only (no automatic retry loops)."
        }
      ]
    },
    {
      "id": "REQ-4",
      "summary": "Make payment result detection and startup routing work reliably on Internet Computer hosting, including hash-based URLs and back/forward navigation.",
      "acceptanceCriteria": [
        "Visiting a hash-based URL for payment results (e.g., `#/payment-success` or equivalent used by the app) correctly renders PaymentSuccessPage after authentication and actor readiness.",
        "Visiting non-payment URLs does not incorrectly trigger the payment flow.",
        "Navigation/back-forward changes update the rendered route without breaking startup."
      ],
      "file_operations": [
        {
          "path": "frontend/src/utils/urlParams.ts",
          "operation": "modify",
          "description": "Add small, focused helpers to derive the current in-app route path in a routing-mode-agnostic way (pathname vs hash route) and to read parameters from both query-string and hash-query consistently, to support IC hash-based URLs."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Replace pathname-only payment route detection with route parsing that supports both browser paths and hash routes (e.g., '#/payment-success' and '#/payment-failure'). Subscribe to both 'popstate' and 'hashchange' so back/forward updates routing reliably without disrupting startup."
        },
        {
          "path": "frontend/src/pages/PaymentSuccessPage.tsx",
          "operation": "modify",
          "description": "Read Stripe session_id in a way compatible with IC hash routing by using the shared URL parameter utilities (instead of window.location.search only), and ensure the page remains stable if session_id is missing."
        },
        {
          "path": "frontend/src/pages/PaymentFailurePage.tsx",
          "operation": "modify",
          "description": "Read Stripe session_id in a way compatible with IC hash routing by using the shared URL parameter utilities (instead of window.location.search only), and ensure navigation actions do not break hash-based hosting."
        }
      ]
    }
  ]
}